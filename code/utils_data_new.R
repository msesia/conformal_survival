# Base class for Survival Data Generation
SurvivalDataGenerator <- R6::R6Class("SurvivalDataGenerator",
  public = list(
    num_features = NULL,

    # Constructor
    # Description: Initializes the SurvivalDataGenerator object with the specified number of features.
    # Inputs:
    #   - num_features: Number of covariates (features) to generate for each sample.
    initialize = function(num_features) {
      self$num_features <- num_features
    },

    # Method to generate covariates X
    # Description: Generates a matrix of covariates with independent uniformly distributed values
    #              between -1 and 1. The number of covariates is specified by `num_features`.
    # Inputs:
    #   - num_samples: Number of samples to generate.
    # Outputs:
    #   - A matrix of size (num_samples x num_features) containing the generated covariates.
    sample_covariates = function(num_samples) {
      X <- matrix(runif(num_samples * self$num_features, -1, 1), nrow = num_samples)
      return(X)
    },

    # Abstract method to generate true survival times T|X
    # Description: This method should be implemented by derived classes to generate true survival times
    #              based on the covariates X and the selected survival model.
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    # Outputs:
    #   - A vector of survival times (T) for each individual.
    sample_true_survival = function(X) {
      stop("This method should be implemented by the derived class.")
    },

    # Abstract method to generate censoring times C|X
    # Description: This method should be implemented by derived classes to generate censoring times
    #              based on the covariates X and the selected model-specific censoring distribution.
    #              If true survival times T are provided, censoring times C should be sampled conditional
    #              on C > T, ensuring that censoring occurs after the event time for each individual.
    #
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    #        The censoring distribution should depend on X in a model-specific way.
    #   - T: (Optional) A vector of true survival times (T) for each individual. If provided,
    #        censoring times should be sampled to ensure that C > T for each individual.
    #
    # Outputs:
    #   - A vector of censoring times (C) for each individual. If T is provided, C will be greater
    #     than the corresponding values of T. Otherwise, censoring times should be sampled independently
    #     based on the covariates.
    sample_censoring_times = function(X, T = NULL) {
      stop("This method should be implemented by the derived class.")
    },

    # Abstract method to predict survival probabilities given failure times
    # Description: This method should be implemented by derived classes to predict survival probabilities
    #              based on the covariates X and provided failure times.
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - failure.times: A numeric vector of failure times.
    #
    # Outputs:
    #   - A list containing:
    #       - predictions: A numeric matrix of survival probabilities for each individual at each failure time.
    #       - failure.times: A numeric vector of the provided failure times.
    predict_survival = function(X, failure.times) {
      stop("This method should be implemented by the derived class.")
    },

    # Default method to predict survival quantiles
    # Description:
    #   This method predicts survival quantiles for a given set of new data. It uses the predicted
    #   survival curves generated by the `predict_survival` method, so the `predict_survival` method
    #   must be implemented in the subclass.
    #
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - probs: A numeric vector of quantile probabilities (e.g., `c(0.25, 0.5, 0.75)` for the 25th, 50th,
    #            and 75th percentiles). These represent the survival probabilities at which the quantile
    #            survival times will be calculated.
    #
    # Outputs:
    #   - A data.frame where each row corresponds to an individual in `new_data`, and each column corresponds
    #     to one of the requested quantiles. The values in the data frame represent the survival times (in terms
    #     of time points) at which the specified survival probabilities (`probs`) are reached.
    predict_quantiles = function(X, probs = c(0.25, 0.5, 0.75), T.max = 1000, tol = 1e-3) {
        ## Predict survival curves

        ## Function to perform adaptive binary search to find the quantile time for a specific survival probability
        adaptive_binary_search <- function(individual_survival_fun, target_prob, T.max, tol) {
            lower <- 0
            upper <- T.max

            ## Check if the survival probability at T.max is still greater than the target
            if (individual_survival_fun(T.max) >= target_prob) {
                return(Inf)
            }

            while (upper - lower > tol) {
                mid <- (lower + upper) / 2
                survival_prob <- individual_survival_fun(mid)

                if (survival_prob >= target_prob) {
                    lower <- mid
                } else {
                    upper <- mid
                }
            }

            return((lower + upper) / 2)
        }

        ## Initialize a list to store quantiles for each individual
        quantiles_list <- list()

        ## Loop over each individual
        for (i in 1:nrow(X)) {
            ## Create a function that returns the survival probability at a given time for this individual
            individual_survival_fun <- function(time_point) {
                ## We calculate the survival probability for this individual at a specific time_point
                return(self$predict_survival(X[i, , drop = FALSE], failure.times = time_point)$predictions)
            }

            ## For each individual, find the survival times at the specified percentiles using adaptive binary search
            quantiles <- sapply(probs, function(p) adaptive_binary_search(individual_survival_fun, 1 - p, T.max, tol))
            quantiles_list[[i]] <- quantiles
        }

        ## Convert the list of quantiles to a data frame
        quantiles_df <- do.call(rbind, quantiles_list)
        colnames(quantiles_df) <- paste0("Q", probs * 100, "%")
        rownames(quantiles_df) <- paste0("Individual_", 1:nrow(quantiles_df))

        return(as.data.frame(quantiles_df))
    },

    # Method to generate the full survival dataset
    # Description: Generates the complete survival dataset, including covariates, true survival times,
    #              censoring times, observed times, and status indicators.
    # Inputs:
    #   - num_samples: Number of samples to generate for the dataset.
    # Outputs:
    #   - A data.frame containing the generated covariates, event times, censoring times, observed times,
    #     status indicators (1 = event, 0 = censored), and covariates.
    sample_survival_data = function(num_samples) {
      # Generate covariates, true survival times, and censoring times
      X <- self$sample_covariates(num_samples)
      T <- self$sample_true_survival(X)
      C <- self$sample_censoring_times(X)

      # Determine observed time and event indicator
      time <- pmin(T, C)
      status <- as.integer(time == T)

      # Create the final dataset
      data <- data.frame(event_time = T, censoring_time = C, time = time,
                         status = status, X)
      return(data)
    }

  )
)

# Derived class for Log-Normal Survival Model
LogNormalSurvivalGenerator <- R6::R6Class("LogNormalSurvivalGenerator",
  inherit = SurvivalDataGenerator,
  public = list(
      num_features = NULL, # Number of features
      mu_fun = NULL,       # Function to calculate mean based on covariates X
      sigma_fun = NULL,    # Function to calculate standard deviation based on covariates X

    # Constructor method to initialize the survival model
    # Inputs:
    #   - num_features: Number of covariates (features) to generate for each sample.
    #   - shape: Shape parameter for the Weibull distribution.
    #   - scale_fun: A function that computes the scale parameter based on covariates X.
    initialize = function(num_features, mu_fun=NULL, sigma_fun=NULL) {
        self$num_features = num_features
        if(is.null(mu_fun)) {
            mu_fun <- function(X) log(2) + 1 + 0.55 * (X[, 1]^2 - X[, 3] * X[, 5])
        }
        if(is.null(sigma_fun)) {
            sigma_fun <- function(X) 0.1 * (abs(X[, 10]) + 1)
        }
      self$mu_fun <- mu_fun
      self$sigma_fun <- sigma_fun
    },

    ## Method to generate true survival times based on a log-normal distribution
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    # Outputs:
    #   - A numeric vector of survival times (T) for each individual.
    sample_true_survival = function(X) {
      num_samples <- nrow(X)
      mu_x <- self$mu_fun(X)
      sigma_x <- self$sigma_fun(X)
      log_T <- rnorm(num_samples, mean = mu_x, sd = sigma_x)
      T <- exp(log_T)
      return(T)
    },

    # Method to predict survival probabilities given failure times
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - failure.times: A numeric vector of failure times.
    #
    # Outputs:
    #   - A list containing:
    #       - predictions: A numeric matrix of survival probabilities for each individual at each failure time.
    #       - failure.times: A numeric vector of the provided failure times.
    predict_survival = function(X, failure.times) {
        ## Initialize a matrix to store survival probabilities
        n_individuals <- nrow(X)
        n_times <- length(failure.times)
        predictions <- matrix(NA, nrow = n_individuals, ncol = n_times)
        
        ## Compute the mean (mu) and standard deviation (sigma) for each individual
        mu_x <- self$mu_fun(X)
        sigma_x <- self$sigma_fun(X)
        
        ## Compute survival probabilities for each individual at each failure time
        for (i in 1:n_individuals) {
            for (j in 1:n_times) {
                ## Compute the survival probability for individual i at time failure.times[j]
                ## S(t) = 1 - P(T <= t) = 1 - Phi((log(t) - mu) / sigma)
                if (failure.times[j] > 0) {  # Ensure time is positive
                    log_t <- log(failure.times[j])
                    predictions[i, j] <- 1 - pnorm((log_t - mu_x[i]) / sigma_x[i])
                } else {
                    predictions[i, j] <- 1  # Survival probability is 1 at time 0
                }
            }
        }
        
        ## Return predictions and failure times
        return(list(predictions = predictions, failure.times = failure.times))
    },
    
    # Internal utility to compute the censoring rate based on covariates
    # Inputs:
    #   - X: A data.frame of covariates.
    # Outputs:
    #   - A numeric vector of censoring rates for each individual.
    compute_censoring_rate = function(X) {
      return(0.05 * (1 - X[, 1]^2))
    },

    # Method to generate censoring times based on a distribution dependent on covariates X.
    # If parameter T is provided, censoring times C are sampled conditional on C > T.
    #
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - T: (Optional) A numeric vector of survival times (T) for each individual. If provided,
    #        censoring times C will be sampled to ensure that C > T for each individual.
    #
    # Outputs:
    #   - A numeric vector of censoring times (C) for each individual. If T is provided, C will be greater
    #     than the corresponding values of T. Otherwise, censoring times are sampled independently.
    sample_censoring_times = function(X, T = NULL) {
      num_samples <- nrow(X)

      # Compute censoring rates using the utility function
      censoring_rate <- self$compute_censoring_rate(X)

      # Sample censoring times from an exponential distribution
      C <- rexp(num_samples, rate = censoring_rate)

      # If true survival times T are provided, shift censoring times so that C > T
      if (!is.null(T)) {
        C <- C + T
      }

      return(C)
    }

  )
)


# Derived class for Weibull Survival Model
WeibullSurvivalGenerator <- R6::R6Class("WeibullSurvivalGenerator",
  inherit = SurvivalDataGenerator,
  public = list(
      num_features = NULL, # Number of features
      shape = NULL,        # Shape parameter for the Weibull distribution
      scale_fun = NULL,    # Function to calculate scale based on covariates X

    # Constructor method to initialize the survival model
    # Inputs:
    #   - num_features: Number of covariates (features) to generate for each sample.
    #   - shape: Shape parameter for the Weibull distribution.
    #   - scale_fun: A function that computes the scale parameter based on covariates X.
    initialize = function(num_features, shape=NULL, scale_fun=NULL) {
        self$num_features = num_features
        if(is.null(shape)) {
            shape <- 1.5  # Default shape parameter
        }
        if(is.null(scale_fun)) {
            scale_fun <- function(X) exp(0.5 + 0.25 * X[, 1] + 0.5 * X[, 2])  # Default scale function
        }
      self$shape <- shape
      self$scale_fun <- scale_fun
    },

    # Method to sample true survival times based on the defined Weibull distribution
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    # Outputs:
    #   - A vector of survival times (T) for each individual.
    sample_true_survival = function(X) {
      num_samples <- nrow(X)

      # Ensure the survival model is defined
      if (is.null(self$shape) || is.null(self$scale_fun)) {
        stop("The survival model is not defined. Please define the model first.")
      }

      # Compute the scale parameter for each individual
      scale <- self$scale_fun(X)

      # Sample survival times from the Weibull distribution
      T <- rweibull(num_samples, shape = self$shape, scale = scale)
      return(T)
    },

    # Method to compute survival probabilities based on the defined Weibull distribution
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    #   - failure.times: A vector of time points at which to compute the survival probabilities.
    # Outputs:
    #   - A matrix of survival probabilities for each individual at each time point.
    predict_survival = function(X, failure.times) {
      num_samples <- nrow(X)

      # Ensure the survival model is defined
      if (is.null(self$shape) || is.null(self$scale_fun)) {
        stop("The survival model is not defined. Please define the model first.")
      }

      # Compute the scale parameter for each individual
      scale <- self$scale_fun(X)

      # Initialize a matrix to store survival probabilities
      survival_probs <- matrix(NA, nrow = num_samples, ncol = length(failure.times))

      # Compute survival probabilities for each individual at each time point
      for (i in 1:num_samples) {
        survival_probs[i, ] <- pweibull(failure.times, shape = self$shape, scale = scale[i], lower.tail = FALSE)
      }

      return(list(predictions = survival_probs, failure.times = failure.times))
    },


    # Internal utility to compute the censoring rate based on covariates
    # Inputs:
    #   - X: A data.frame of covariates.
    # Outputs:
    #   - A numeric vector of censoring rates for each individual.
    compute_censoring_rate = function(X) {
      return(0.05 * (1 - X[, 1]^2))
    },

    # Method to generate censoring times based on a distribution dependent on covariates X.
    # If parameter T is provided, censoring times C are sampled conditional on C > T.
    #
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    #        Censoring times are influenced by specific covariates (e.g., X1).
    #   - T: (Optional) A vector of survival times (T) for each individual. If provided,
    #        censoring times C will be sampled to ensure that C > T for each individual.
    #
    # Outputs:
    #   - A vector of censoring times (C) for each individual. If T is provided, C will be greater
    #     than the corresponding values of T. Otherwise, censoring times are sampled independently
    #     based on the covariates.
    sample_censoring_times = function(X, T=NULL) {
      num_samples <- nrow(X)

      # Compute censoring rates using the utility function
      censoring_rate <- self$compute_censoring_rate(X)

      # Sample censoring times from an exponential distribution
      C <- rexp(num_samples, rate = censoring_rate)

      # If true survival times T are provided, shift censoring times so that C > T
      if (!is.null(T)) {
        C <- C + T
      }

      return(C)
    }

  )
)
