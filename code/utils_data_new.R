# Base class for Survival Data Generation
SurvivalDataGenerator <- R6::R6Class("SurvivalDataGenerator",
  public = list(
    num_features = NULL,

    # Constructor
    # Description: Initializes the SurvivalDataGenerator object with the specified number of features.
    # Inputs:
    #   - num_features: Number of covariates (features) to generate for each sample.
    initialize = function(num_features) {
      self$num_features <- num_features
    },

    # Method to generate covariates X
    # Description: Generates a matrix of covariates with independent uniformly distributed values
    #              between -1 and 1. The number of covariates is specified by `num_features`.
    # Inputs:
    #   - num_samples: Number of samples to generate.
    # Outputs:
    #   - A matrix of size (num_samples x num_features) containing the generated covariates.
    sample_covariates = function(num_samples) {
      X <- matrix(runif(num_samples * self$num_features, -1, 1), nrow = num_samples)
      return(X)
    },

    # Abstract method to generate true survival times T|X
    # Description: This method should be implemented by derived classes to generate true survival times
    #              based on the covariates X and the selected survival model.
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    # Outputs:
    #   - A vector of survival times (T) for each individual.
    sample_true_survival = function(X) {
      stop("This method should be implemented by the derived class.")
    },

    # Abstract method to generate censoring times C|X
    # Description: This method should be implemented by derived classes to generate censoring times
    #              based on the covariates X and the selected model-specific censoring distribution.
    #              If true survival times T are provided, censoring times C should be sampled conditional
    #              on C > T, ensuring that censoring occurs after the event time for each individual.
    #
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    #        The censoring distribution should depend on X in a model-specific way.
    #   - T: (Optional) A vector of true survival times (T) for each individual. If provided,
    #        censoring times should be sampled to ensure that C > T for each individual.
    #
    # Outputs:
    #   - A vector of censoring times (C) for each individual. If T is provided, C will be greater
    #     than the corresponding values of T. Otherwise, censoring times should be sampled independently
    #     based on the covariates.
    sample_censoring_times = function(X, T = NULL) {
      stop("This method should be implemented by the derived class.")
    },

    # Abstract method to predict survival probabilities at given times
    # Description: This method should be implemented by derived classes to predict survival probabilities
    #              based on the covariates X and provided time points.
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - time.points: A numeric vector of time points.
    #
    # Outputs:
    #   - A list containing:
    #       - predictions: A numeric matrix of survival probabilities for each individual at each failure time.
    #       - time.points: A numeric vector of the provided time points.
    predict_survival = function(X, time.points) {
      stop("This method should be implemented by the derived class.")
    },

    # Abstract method to predict survival quantiles based on the underlying survival model
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #        This data frame should not include columns 'time' or 'status'.
    #   - probs: A numeric vector of probabilities for which to compute the quantiles (e.g., c(0.25, 0.5, 0.75)).
    #            These represent the quantiles of the survival time distribution, with default values of 25%, 50%, and 75%.
    #
    # Outputs:
    #   - A data.frame where each row corresponds to an individual in `X`, and each column corresponds to one of the 
    #     requested quantiles specified in `probs`. The values in the data.frame represent the survival times (in terms of
    #     time points) at which the specified survival probabilities (`probs`) are reached.
    #       - Each column is named as Q25%, Q50%, Q75%, etc., corresponding to the quantile levels in `probs`.
    #       - Each row is named as 'Individual_1', 'Individual_2', ..., corresponding to each individual in `X`.
    predict_quantiles = function(X, probs = c(0.25, 0.5, 0.75)) {        
        stop("This method should be implemented by the derived class.")
    },

    # Abstract method to predict censoring probabilities at given times
    # Description: This method should be implemented by derived classes to predict censoring probabilities
    #              based on the covariates X and provided time points.
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - time.points: A numeric vector of time points.
    #
    # Outputs:
    #   - A list containing:
    #       - predictions: A numeric matrix of censoring probabilities for each individual at each failure time.
    #       - time.points: A numeric vector of the provided time points.
    predict_censoring = function(X, time.points) {
      stop("This method should be implemented by the derived class.")
    },
    
    # Method to generate the full survival dataset
    # Description: Generates the complete survival dataset, including covariates, true survival times,
    #              censoring times, observed times, and status indicators.
    # Inputs:
    #   - num_samples: Number of samples to generate for the dataset.
    # Outputs:
    #   - A data.frame containing the generated covariates, event times, censoring times, observed times,
    #     status indicators (1 = event, 0 = censored), and covariates.
    sample_survival_data = function(num_samples) {
      # Generate covariates, true survival times, and censoring times
      X <- self$sample_covariates(num_samples)
      T <- self$sample_true_survival(X)
      C <- self$sample_censoring_times(X)

      # Determine observed time and event indicator
      time <- pmin(T, C)
      status <- as.integer(time == T)

      # Create the final dataset
      data <- data.frame(event_time = T, censoring_time = C, time = time,
                         status = status, X)
      return(data)
    }

  )
)

# Derived class for Log-Normal Survival Model
LogNormalSurvivalGenerator <- R6::R6Class("LogNormalSurvivalGenerator",
  inherit = SurvivalDataGenerator,
  public = list(
      num_features = NULL,           # Number of features
      mu_fun = NULL,                 # Function to calculate mean based on covariates X
      sigma_fun = NULL,              # Function to calculate standard deviation based on covariates X
      compute_censoring_rate = NULL, # Function to calculate censoring rate based on covariates X

    # Constructor method to initialize the survival model
    # Inputs:
    #   - num_features: Number of covariates (features) to generate for each sample.
    #   - shape: Shape parameter for the Weibull distribution.
    #   - scale_fun: A function that computes the scale parameter based on covariates X.
    #   - cens_rate_fun: A function that computes the censoring rate based on covariates X.
    initialize = function(num_features, mu_fun=NULL, sigma_fun=NULL, cens_rate_fun = NULL) {
        self$num_features = num_features
        if(is.null(mu_fun)) {
            mu_fun <- function(X) log(2) + 1 + 0.55 * (X[, 1]^2 - X[, 3] * X[, 5])
        }
        if(is.null(sigma_fun)) {
            sigma_fun <- function(X) 0.1 * (abs(X[, 10]) + 1)
        }
        if(is.null(cens_rate_fun)) {
            cens_rate_fun <- function(X) return(0.05 * (1 - X[, 1]^2))
        }

        self$mu_fun <- mu_fun
        self$sigma_fun <- sigma_fun
        self$compute_censoring_rate <- cens_rate_fun
    },

    ## Method to generate true survival times based on a log-normal distribution
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    # Outputs:
    #   - A numeric vector of survival times (T) for each individual.
    sample_true_survival = function(X) {
      num_samples <- nrow(X)
      mu_x <- self$mu_fun(X)
      sigma_x <- self$sigma_fun(X)
      log_T <- rnorm(num_samples, mean = mu_x, sd = sigma_x)
      T <- exp(log_T)
      return(T)
    },

    # Method to predict survival probabilities at given times
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - time.points: A numeric vector of time points.
    #
    # Outputs:
    #   - A list containing:
    #       - predictions: A numeric matrix of survival probabilities for each individual at each failure time.
    #       - time.points: A numeric vector of the provided time points.
    predict_survival = function(X, time.points) {
        if(is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }
        ## Initialize a matrix to store survival probabilities
        n_individuals <- nrow(X)
        n_times <- length(time.points)
        predictions <- matrix(NA, nrow = n_individuals, ncol = n_times)

        ## Compute the mean (mu) and standard deviation (sigma) for each individual
        mu_x <- self$mu_fun(X)
        sigma_x <- self$sigma_fun(X)

        ## Compute survival probabilities for each individual at each failure time
        for (i in 1:n_individuals) {
            for (j in 1:n_times) {
                ## Compute the survival probability for individual i at time time.points[j]
                ## S(t) = 1 - P(T <= t) = 1 - Phi((log(t) - mu) / sigma)
                if (time.points[j] > 0) {  # Ensure time is positive
                    log_t <- log(time.points[j])
                    predictions[i, j] <- 1 - pnorm((log_t - mu_x[i]) / sigma_x[i])
                } else {
                    predictions[i, j] <- 1  # Survival probability is 1 at time 0
                }
            }
        }

        ## Return predictions and time points
        return(list(predictions = predictions, time.points = time.points))
    },

    # Method to predict survival quantiles based on the log-normal model
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #        This data frame should not include columns 'time' or 'status'.
    #   - probs: A numeric vector of probabilities for which to compute the quantiles (e.g., c(0.25, 0.5, 0.75)).
    #            These represent the quantiles of the survival time distribution, with default values of 25%, 50%, and 75%.
    #
    # Outputs:
    #   - A data.frame where each row corresponds to an individual in `X`, and each column corresponds to one of the 
    #     requested quantiles specified in `probs`. The values in the data.frame represent the survival times (in terms of
    #     time points) at which the specified survival probabilities (`probs`) are reached.
    #       - Each column is named as Q25%, Q50%, Q75%, etc., corresponding to the quantile levels in `probs`.
    #       - Each row is named as 'Individual_1', 'Individual_2', ..., corresponding to each individual in `X`.
    predict_quantiles = function(X, probs = c(0.25, 0.5, 0.75)) {

      # Ensure that we are working with a data frame excluding time and status if present
      if (is.data.frame(X)) {
        X <- X |> select(-any_of(c("time", "status")))
      }

      # Initialize a matrix to store the quantiles
      n_individuals <- nrow(X)
      n_probs <- length(probs)
      quantiles_matrix <- matrix(NA, nrow = n_individuals, ncol = n_probs)

      # Compute the mean (mu) and standard deviation (sigma) for each individual
      mu_x <- self$mu_fun(X)
      sigma_x <- self$sigma_fun(X)

      # Loop over each individual and compute quantiles directly using the log-normal model
      for (i in 1:n_individuals) {
        for (j in 1:n_probs) {
          # Use the inverse survival function formula to compute the quantile
          quantiles_matrix[i, j] <- exp(mu_x[i] + sigma_x[i] * qnorm(probs[j]))
        }
      }

      # Convert the quantiles matrix to a data frame
      quantiles_df <- as.data.frame(quantiles_matrix)
      colnames(quantiles_df) <- paste0("Q", probs * 100, "%")
      rownames(quantiles_df) <- paste0("Individual_", 1:nrow(quantiles_df))

      return(quantiles_df)
    },

    # Method to generate censoring times based on a distribution dependent on covariates X.
    # If parameter T is provided, censoring times C are sampled conditional on C > T.
    #
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - T: (Optional) A numeric vector of survival times (T) for each individual. If provided,
    #        censoring times C will be sampled to ensure that C > T for each individual.
    #
    # Outputs:
    #   - A numeric vector of censoring times (C) for each individual. If T is provided, C will be greater
    #     than the corresponding values of T. Otherwise, censoring times are sampled independently.
    sample_censoring_times = function(X, T = NULL) {
        if(is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        num_samples <- nrow(X)

        ## Compute censoring rates using the utility function
        censoring_rate <- self$compute_censoring_rate(X)

        ## Sample censoring times from an exponential distribution
        C <- rexp(num_samples, rate = censoring_rate)

        ## If true survival times T are provided, shift censoring times so that C > T
        if (!is.null(T)) {
            C <- C + T
        }

        return(C)
    },

    # Method to predict censoring probabilities at given time points
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - time.points: A numeric vector of time points..
    #
    # Outputs:
    #   - A list containing:
    #       - predictions: A numeric matrix of censoring probabilities for each individual at each time point.
    #       - time.points: A numeric vector of the provided time points.
    predict_censoring = function(X, time.points) {
        if(is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        num_samples <- nrow(X)

        ## Compute censoring rates using the utility function
        censoring_rate <- self$compute_censoring_rate(X)

        ## Initialize a matrix to store survival probabilities
        n_individuals <- nrow(X)
        n_times <- length(time.points)
        predictions <- matrix(NA, nrow = n_individuals, ncol = n_times)

        ## Compute survival probabilities for each individual at each failure time
        for (i in 1:n_individuals) {
            predictions[i,] <- pexp(time.points, rate = censoring_rate[i], lower.tail=FALSE)
        }

        ## Return predictions and time points
        return(list(predictions = predictions, time.points = time.points))
    }
    

  )
)


# Derived class for Weibull Survival Model
WeibullSurvivalGenerator <- R6::R6Class("WeibullSurvivalGenerator",
  inherit = SurvivalDataGenerator,
  public = list(
      num_features = NULL,           # Number of features
      shape = NULL,                  # Shape parameter for the Weibull distribution
      scale_fun = NULL,              # Function to calculate scale parameter based on covariates X
      compute_censoring_rate = NULL, # Function to calculate censoring rate based on covariates X

    # Constructor method to initialize the survival model
    # Inputs:
    #   - num_features: Number of covariates (features) to generate for each sample.
    #   - shape: Shape parameter for the Weibull distribution.
    #   - scale_fun: A function that computes the scale parameter based on covariates X.
    #   - cens_rate_fun: A function that computes the censoring rate based on covariates X.
    initialize = function(num_features, shape=NULL, scale_fun=NULL, cens_rate_fun = NULL) {
        self$num_features = num_features
        if(is.null(shape)) {
            shape <- 1.5  # Default shape parameter
        }
        if(is.null(scale_fun)) {
            scale_fun <- function(X) exp(0.5 + 0.25 * X[, 1] + 0.5 * X[, 2])  # Default scale function
        }
        if(is.null(cens_rate_fun)) {
            cens_rate_fun <- function(X) return(0.05 * (1 - X[, 1]^2))
        }

        self$shape <- shape
        self$scale_fun <- scale_fun
        self$compute_censoring_rate <- cens_rate_fun
    },

    # Method to sample true survival times based on the defined Weibull distribution
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    # Outputs:
    #   - A vector of survival times (T) for each individual.
    sample_true_survival = function(X) {
      num_samples <- nrow(X)

      # Ensure the survival model is defined
      if (is.null(self$shape) || is.null(self$scale_fun)) {
        stop("The survival model is not defined. Please define the model first.")
      }

      # Compute the scale parameter for each individual
      scale <- self$scale_fun(X)

      # Sample survival times from the Weibull distribution
      T <- rweibull(num_samples, shape = self$shape, scale = scale)
      return(T)
    },

    # Method to compute survival probabilities based on the defined Weibull distribution
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    #   - time.points: A vector of time points at which to compute the survival probabilities.
    # Outputs:
    #   - A matrix of survival probabilities for each individual at each time point.
    predict_survival = function(X, time.points) {
        if(is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }
      num_samples <- nrow(X)

      # Ensure the survival model is defined
      if (is.null(self$shape) || is.null(self$scale_fun)) {
        stop("The survival model is not defined. Please define the model first.")
      }

      # Compute the scale parameter for each individual
      scale <- self$scale_fun(X)

      # Initialize a matrix to store survival probabilities
      survival_probs <- matrix(NA, nrow = num_samples, ncol = length(time.points))

      # Compute survival probabilities for each individual at each time point
      for (i in 1:num_samples) {
        survival_probs[i, ] <- pweibull(time.points, shape = self$shape, scale = scale[i], lower.tail = FALSE)
      }

      return(list(predictions = survival_probs, time.points = time.points))
    },

    # Method to predict survival quantiles based on the Weibull model
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #        This data frame should not include columns 'time' or 'status'.
    #   - probs: A numeric vector of probabilities for which to compute the quantiles (e.g., c(0.25, 0.5, 0.75)).
    #            These represent the quantiles of the survival time distribution, with default values of 25%, 50%, and 75%.
    #
    # Outputs:
    #   - A data.frame where each row corresponds to an individual in `X`, and each column corresponds to one of the 
    #     requested quantiles specified in `probs`. The values in the data.frame represent the survival times (in terms of
    #     time points) at which the specified survival probabilities (`probs`) are reached.
    #       - Each column is named as Q25%, Q50%, Q75%, etc., corresponding to the quantile levels in `probs`.
    #       - Each row is named as 'Individual_1', 'Individual_2', ..., corresponding to each individual in `X`.
    predict_quantiles = function(X, probs = c(0.25, 0.5, 0.75)) {

        # Ensure that we are working with a data frame excluding time and status if present
        if (is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        # Initialize a matrix to store the quantiles
        n_individuals <- nrow(X)
        n_probs <- length(probs)
        quantiles_matrix <- matrix(NA, nrow = n_individuals, ncol = n_probs)

        # Ensure the survival model is defined
        if (is.null(self$shape) || is.null(self$scale_fun)) {
            stop("The survival model is not defined. Please define the model first.")
        }

        # Compute the scale parameter for each individual
        scale <- self$scale_fun(X)

        # Loop over each individual and compute quantiles directly using the Weibull model
        for (i in 1:n_individuals) {
            for (j in 1[n_probs]) {
                # Use the Weibull quantile formula to compute the quantile
                quantiles_matrix[i, j] <- scale[i] * (-log(1 - probs[j]))^(1 / self$shape)
            }
        }

        # Convert the quantiles matrix to a data frame
        quantiles_df <- as.data.frame(quantiles_matrix)
        colnames(quantiles_df) <- paste0("Q", probs * 100, "%")
        rownames(quantiles_df) <- paste0("Individual_", 1:nrow(quantiles_df))

        return(quantiles_df)
    },


    # Method to generate censoring times based on a distribution dependent on covariates X.
    # If parameter T is provided, censoring times C are sampled conditional on C > T.
    #
    # Inputs:
    #   - X: A matrix of covariates generated by the `sample_covariates` method.
    #        Censoring times are influenced by specific covariates (e.g., X1).
    #   - T: (Optional) A vector of survival times (T) for each individual. If provided,
    #        censoring times C will be sampled to ensure that C > T for each individual.
    #
    # Outputs:
    #   - A vector of censoring times (C) for each individual. If T is provided, C will be greater
    #     than the corresponding values of T. Otherwise, censoring times are sampled independently
    #     based on the covariates.
    sample_censoring_times = function(X, T=NULL) {
      num_samples <- nrow(X)

      # Compute censoring rates using the utility function
      censoring_rate <- self$compute_censoring_rate(X)

      # Sample censoring times from an exponential distribution
      C <- rexp(num_samples, rate = censoring_rate)

      # If true survival times T are provided, shift censoring times so that C > T
      if (!is.null(T)) {
        C <- C + T
      }

      return(C)
    },

    # Method to predict censoring probabilities at given time points
    # Inputs:
    #   - X: A data.frame of covariates generated by the `sample_covariates` method.
    #   - time.points: A numeric vector of time points..
    #
    # Outputs:
    #   - A list containing:
    #       - predictions: A numeric matrix of censoring probabilities for each individual at each time point.
    #       - time.points: A numeric vector of the provided time points.
    predict_censoring = function(X, time.points) {
        if(is.data.frame(X)) {
            X <- X |> select(-any_of(c("time", "status")))
        }

        num_samples <- nrow(X)

        ## Compute censoring rates using the utility function
        censoring_rate <- self$compute_censoring_rate(X)

        ## Initialize a matrix to store survival probabilities
        n_individuals <- nrow(X)
        n_times <- length(time.points)
        predictions <- matrix(NA, nrow = n_individuals, ncol = n_times)

        ## Compute survival probabilities for each individual at each failure time
        for (i in 1:n_individuals) {
            predictions[i,] <- pexp(time.points, rate = censoring_rate[i], lower.tail=FALSE)
        }

        ## Return predictions and time points
        return(list(predictions = predictions, time.points = time.points))
    }
    

  )
)
